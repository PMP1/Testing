//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Collections;
using UnityEngine;

namespace AssemblyCSharp
{
    public class ChunkManager
    {
        private Hashtable chunkCollection = new Hashtable();
        //public List<Chunk2> requiresGOgeneration = new List<Chunk2>();
        public Queue<Chunk2> requiresGOgeneration = new Queue<Chunk2>();

        private BlockLightUpdate[] collection = new BlockLightUpdate[32*32*32];

        private System.Object thisLock = new System.Object();

        public GameObject worldGO;
        public World world;
        //AbstractWorldGenerator worldGenerator;

        public ChunkRenderer renderer;

        public ChunkManager(World world)
        {
            this.world = world;
            this.renderer = new ChunkRenderer(this, world);
            //TODO convert generator from static class
            //worldGenerator = new PerlinWorldGenerator();
            //worldGenerator.init();
            //worldGenerator.setSeed(world.configSettings.Seed());
        }

        public bool LoadChunkWithinDist(int startChunkX, int startChunkZ, int blockDist, int maxLoad)
        {
            int currentLoad = 0;
            int chunkx = startChunkX >> 4;
            int chunkz = startChunkZ >> 4;
            int chunkdist = blockDist >> 4;
            int minX = chunkx - chunkdist;
            int minZ = chunkz - chunkdist;
            int maxX = chunkx + chunkdist;
            int maxZ = chunkz + chunkdist;

            for (int x = minX; x < maxX; x++)
            {
                for (int z = minZ; z < maxZ; z++)
                {
                    Chunk2 chunk = GetChunk(x, z);
                    if (chunk == null) 
                    {
                        ChunkLoader.RequestChunk(this, x, z);
                        //this.LoadChunk(x, z);
                        currentLoad ++;
                        if (currentLoad >= maxLoad) return true;
                    }
                    
                }

            }
            return false;
        }

        public void LoadChunk(int x, int z) 
        {
            System.DateTime genStart = System.DateTime.Now;

            Chunk2 chunk = new Chunk2(this, x, z);
            PerlinWorldGenerator.CreateChunk(chunk);

            chunkCollection.Add(x + ":" + z, chunk);

            chunk.isDataLoaded = true;
            StatsEngine.ChunkGenTime += (float)System.DateTime.Now.Subtract(genStart).TotalSeconds;
        }

       

        public void UnLoadChunk(int x, int z)
        {

        }



        public void SaveChunk(int x, int z)
        {

        }

        public void RenderInnitialChunks() 
        {
            System.DateTime renStart = System.DateTime.Now;
            foreach (var key in chunkCollection.Keys)
            {
                renderer.RenderChunk((Chunk2)chunkCollection[key]);
            }
            StatsEngine.ChunkRenderTime += (float)System.DateTime.Now.Subtract(renStart).TotalSeconds;
        }


        public void RenderMissingGOs()
        {
            //lock (thisLock)
            {
                Chunk2 chunk;
                while (requiresGOgeneration.Count > 0)
                {

                    chunk = requiresGOgeneration.Dequeue();
                    if (chunk == null) return;

                    chunk.GenerateSecGO();

                    //have we completed all the direct neighbours for any surrounding chunk?
                    //if we have we need to re render to remove any artifacts
                    if (DoChunksExist(chunk.xPosition - 1, chunk.zPosition, false))
                    {
                        Chunk2 cnk = GetChunk(chunk.xPosition - 1, chunk.zPosition);
                        if (!cnk.isNeighboursLoaded)
                        {
                        cnk.isNeighboursLoaded = true;
                        ChunkLoader.RequestChunkRegeneration(this, cnk);
                        }
                    }
                    if (DoChunksExist(chunk.xPosition + 1, chunk.zPosition, false))
                    {
                        Chunk2 cnk = GetChunk(chunk.xPosition + 1, chunk.zPosition);
                        if (!cnk.isNeighboursLoaded)
                        {
                            cnk.isNeighboursLoaded = true;
                            ChunkLoader.RequestChunkRegeneration(this, cnk);
                        }
                    }
                    if (DoChunksExist(chunk.xPosition, chunk.zPosition + 1, false))
                    {
                        Chunk2 cnk = GetChunk(chunk.xPosition, chunk.zPosition + 1);
                        if (!cnk.isNeighboursLoaded)
                        {
                            cnk.isNeighboursLoaded = true;
                            ChunkLoader.RequestChunkRegeneration(this, cnk);
                        }
                    }
                    if (DoChunksExist(chunk.xPosition, chunk.zPosition - 1, false))
                    {
                        Chunk2 cnk = GetChunk(chunk.xPosition, chunk.zPosition - 1);
                        if (!cnk.isNeighboursLoaded)
                        {
                            cnk.isNeighboursLoaded = true;
                            ChunkLoader.RequestChunkRegeneration(this, cnk);
                        }
                    }
                }
            }
        }


        private void CheckNeighboursLoaded()
        {

        }
       

        public Chunk2 GetChunk(int x, int z)
        {
            //TODO should I have the concept of an empty chunk?
            Chunk2 chunk = (Chunk2)chunkCollection [x + ":" + z];
            return chunk;
        }

        public void SetChunk(int x, int z, Chunk2 chunk)
        {
            chunkCollection.Add(x + ":" + z, chunk);
        }

        public int GetBlockId(int x, int y, int z)
        {
            if (y >= 256 || y < 0)
            {
                return 0;
            } else
            {
                int xPos = x / 16;
                int zPos = z / 16;
                //int xSectionPos = x % 16;
                //int zSectionPos = z % 16;

                int xSectionPos = x - (xPos * 16);
                int zSectionPos = z - (zPos * 16);

                Chunk2 chunk = this.GetChunk(xPos, zPos);
                if (chunk == null) 
                {
                    return 3;
                    //throw new ArgumentNullException();
                }
                return chunk.GetBlockId(xSectionPos, y, zSectionPos);
            }
        }

        public Block GetBlock(int x, int y, int z)
        {
            int blockId = this.GetBlockId(x, y, z);
            return BlockManager.GetBlock((byte)blockId);
        }

        public int GetHeightAt(int x, int z)
        {
            int xPos = x / 16;
            int zPos = z / 16;
            int xSectionPos = x % 16;
            int zSectionPos = z % 16;
            
            Chunk2 chunk = this.GetChunk(xPos, zPos);
            return chunk.heightMap[xSectionPos + 16 * zSectionPos];
        }


        #region Chunk Exists
        public bool DoChunksExist(int x, int y, int z, int blockDist)
        {
            return this.DoChunksExist(x - blockDist, x + blockDist, y - blockDist, y + blockDist, z - blockDist, z + blockDist);
        }

        public bool DoChunksExist(int minX, int maxX, int minY, int maxY, int minZ, int maxZ)
        {
            minX /= 16;
            maxX /= 16;
            minZ /= 16;
            maxZ /= 16;

            for (int x = minX; x <= maxX; x++)
            {
                for (int z = minZ; z<= minZ; z++)
                {
                    if (!this.DoesChunkExist(x, z))
                        return false;
                }
            }
            return true;
        }

        public bool DoChunksExist(int chunkX, int chunkZ, bool includeDiagonal)
        {
            if (!DoesChunkExist(chunkX + 1, chunkZ)) return false;
            if (!DoesChunkExist(chunkX - 1, chunkZ)) return false;
            if (!DoesChunkExist(chunkX, chunkZ + 1)) return false;
            if (!DoesChunkExist(chunkX, chunkZ - 1)) return false;

            if (includeDiagonal)
            {
                if (!DoesChunkExist(chunkX + 1, chunkZ + 1)) return false;
                if (!DoesChunkExist(chunkX - 1, chunkZ + 1)) return false;
                if (!DoesChunkExist(chunkX + 1, chunkZ - 1)) return false;
                if (!DoesChunkExist(chunkX - 1, chunkZ - 1)) return false;
            }

            return true;
        }

        public bool DoesChunkExist(int x, int y)
        {
            if (chunkCollection.Contains(x + ":" + y))
                return true;
            return false;
        }
        #endregion

        #region Light


        public void SpreadLightToAllChunks()
        {

            System.DateTime start = System.DateTime.Now;
            foreach (var key in chunkCollection.Keys)
            {
                ((Chunk2)chunkCollection[key]).SpreadDaylight();
            }
            StatsEngine.ChunkSpreadLight += (float)System.DateTime.Now.Subtract(start).TotalSeconds;

        }

        public int GetLightValue(int x, int y, int z)
        {
            if (y >= 256 || y < 0)
            {
                return 15;
            } else
            {
                int xPos = x / 16;
                int zPos = z / 16;

                int xSectionPos = x - (xPos * 16);
                int zSectionPos = z - (zPos * 16);
                
                Chunk2 chunk = this.GetChunk(xPos, zPos);
                if (chunk == null) 
                {
                    return 15;
                    //throw new ArgumentNullException();
                }
                return (int)chunk.GetDaylightValue(xSectionPos, y, zSectionPos);
            }
        }

        public void SetLightValue(int x, int y, int z, int level)
        {
            if (y >= 256 || y < 0)
            {
                return;
            } else
            {
                int xPos = x / 16;
                int zPos = z / 16;
                
                int xSectionPos = x - (xPos * 16);
                int zSectionPos = z - (zPos * 16);
                
                Chunk2 chunk = this.GetChunk(xPos, zPos);
                if (chunk == null) 
                {
                    return;
                }
                chunk.SetDaylightValue(xSectionPos, y, zSectionPos, (byte)level);
            }
        }

        public void UpdateDaylight(byte light)
        {
           foreach (var key in chunkCollection.Keys)
            {
                ((Chunk2)chunkCollection[key]).UpdateDaylight(light);
            }
        }

        public void UpdateLightBlock(int x, int y, int z, byte level)
        {

            ChunkCache cache = new ChunkCache(x, z, 17, this);
            //origin x, y, z
            //current x, y, z
            //current level
            int capacity = 0;
            int current = 0;

            //if (DoChunksExist(x, y, x, 17))
            {

                collection [capacity++] = new BlockLightUpdate(x, y, z, level);

                while (capacity > current)
                {
                    int n = 0;
                    int s = 0;
                    int t = 0;
                    int b = 0;
                    int e = 0;
                    int w = 0;
                    bool neightboursLoaded = false;

                    BlockLightUpdate block = collection [current++];

                    int posX = block.posX;
                    int posY = block.posY;
                    int posZ = block.posZ;

                    int savedValue = cache.GetLightValue(posX,posY,posZ);

                    int calcValue = 0;

                    if (cache.FacesTheSky(posX, posY, posZ))
                    {
                        calcValue = 15;
                    } else
                    {
                        n = cache.GetLightValue(posX, posY, posZ + 1);
                        s = cache.GetLightValue(posX, posY, posZ - 1);
                        t = cache.GetLightValue(posX, posY + 1, posZ);
                        b = cache.GetLightValue(posX, posY - 1, posZ);
                        e = cache.GetLightValue(posX + 1, posY, posZ);
                        w = cache.GetLightValue(posX - 1, posY, posZ);

                        neightboursLoaded = true;
                        calcValue = CalcLightValue(posX, posY, posZ, n, s, e, w, t, b);
                    }

                    if (calcValue != savedValue)
                    {
                        cache.SetLightValue(posX, posY, posZ, calcValue);

                        if (capacity < 32762) 
                        {
                            if (calcValue > savedValue)
                            {
                                if (!neightboursLoaded)
                                {
                                    n = cache.GetLightValue(posX, posY, posZ + 1);
                                    s = cache.GetLightValue(posX, posY, posZ - 1);
                                    t = cache.GetLightValue(posX, posY + 1, posZ);
                                    b = cache.GetLightValue(posX, posY - 1, posZ);
                                    e = cache.GetLightValue(posX + 1, posY, posZ);
                                    w = cache.GetLightValue(posX - 1, posY, posZ);
                                }

                                //calc distance from staret if (
                                int diffX = Math.Abs(posX - x);
                                int diffY = Math.Abs(posY - y);
                                int diffZ = Math.Abs(posZ - z); 

                                if (diffX + diffY + diffZ < 18)
                                {
                                    if (n < calcValue)
                                    {
                                        collection [capacity++] = new BlockLightUpdate(posX, posY, posZ + 1, calcValue);
                                    }
                                    if (s < calcValue)
                                    {
                                        collection [capacity++] = new BlockLightUpdate(posX, posY, posZ - 1, calcValue);
                                    }
                                    if (e < calcValue)
                                    {
                                        collection [capacity++] = new BlockLightUpdate(posX + 1, posY, posZ, calcValue);
                                    }
                                    if (w < calcValue)
                                    {
                                        collection [capacity++] = new BlockLightUpdate(posX - 1, posY, posZ, calcValue);
                                    }
                                    if (t < calcValue)
                                    {
                                        collection [capacity++] = new BlockLightUpdate(posX, posY + 1, posZ, calcValue);
                                    }
                                    if (b < calcValue)
                                    {
                                        collection [capacity++] = new BlockLightUpdate(posX, posY - 1, posZ, calcValue);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        private int CalcLightValue(int x, int y, int z, int n, int s, int e, int w, int t, int b)
        {
            int level = 0;

            int opacity = GetBlock(x, y, z).LightOpacity;

            if (opacity >= 15)
            {
                return 0;
            }

            n--;
            s--;
            e--;
            w--;
            t--;
            b--;

            if (n > level)
                level = n;
            if (s > level)
                level = s;
            if (t > level)
                level = t;
            if (b > level)
                level = b;
            if (e > level)
                level = e;
            if (w > level)
                level = w;

            return level;
        }

        #endregion
    }
}

