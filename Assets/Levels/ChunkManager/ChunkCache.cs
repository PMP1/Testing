//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
namespace AssemblyCSharp
{
    public class ChunkCache
    {

        private Chunk2[,] chunkCache;

        private ChunkManager manager;

        private int xMax;
        private int zMax;
        private int xMin;
        private int zMin;

        private int centerX;
        private int centerZ;
        private int centerChunkX;
        private int centerChunkZ;
        private int xChunkMin;
        private int zChunkMin;
        private int xChunkMax;
        private int zChunkMax;
        
        private int xChunks;
        private int zChunks;

        private int _chunkX;
        private int _chunkZ;
        private int _dist;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="x">The global x coordinate.</param>
        /// <param name="z">The global z coordinate.</param>
        /// <param name="dist">Dist.</param>
        public ChunkCache(int x, int z, int dist, ChunkManager chunkManager)
        {
            manager = chunkManager;

            _chunkX = x >> 4;
            _chunkZ = z >> 4;
            _dist = dist;

            xMax = x + dist;
            zMax = z + dist;
            xMin = x - dist;
            zMin = z - dist;

            xChunkMin = xMin / 16;
            zChunkMin = zMin / 16;
            xChunkMax = xMax / 16;
            zChunkMax = zMax / 16;

            xChunks = xChunkMax - xChunkMin + 1;
            zChunks = zChunkMax - zChunkMin + 1;

            centerX = x;
            centerZ = z;
            centerChunkX = (x / 16) - xChunkMin;
            centerChunkZ = (z / 16) - zChunkMin;

            LoadChunks();
        }

        private void LoadChunks()
        {
            chunkCache = new Chunk2[xChunks, zChunks];

            for (int x = xChunkMin; x <= xChunkMax; x++)
            {
                for (int z = zChunkMin; z <= zChunkMax; z++)
                {
                    chunkCache[x - xChunkMin, z - zChunkMin] = manager.GetChunk(x, z);
                }
            }
        }

        #region GetBlockCode

        private Chunk2 GetChunk(int relX, int relZ)
        {
            Chunk2 chunk = chunkCache[relX + centerChunkX, relZ + centerChunkZ];
            return chunk;
        }

        #endregion

        #region HeightMap
        public int GetHeightMap(int globalX, int globalZ)
        {
            int relX = (globalX) - xMin;
            int relZ = (globalZ) - zMin;

            int chunkposX = globalX - ((globalX / 16) * 16);
            int chunkposZ = globalZ - ((globalZ / 16) * 16);

            Chunk2 chunk = GetChunk(relX, relZ);
            if (chunk == null)
            {
                return 255;
            } 
            else
            {
                return chunk.GetHeightMap(chunkposX, chunkposZ);
            }
        }

        public bool FacesTheSky(int globalX, int globalY, int globalZ)
        {
            int chunkX = globalX >> 4;
            int chunkZ = globalZ >> 4;
            
            int relChunkX = chunkX - _chunkX;
            int relChunkZ = chunkZ - _chunkZ;
            
            int chunkposX = globalX - (chunkX * 16);
            int chunkposZ = globalZ - (chunkZ * 16);
            
            Chunk2 chunk;

            try
            {
                chunk = GetChunk(relChunkX, relChunkZ);
                if (chunk == null) 
                {
                    return true;
                }

                byte height = chunk.GetHeightMap(chunkposX, chunkposZ);
                
                if ((int)height == globalY)
                {
                    return true; // is directly touched by sunlight
                }
            }
            catch
            {
                return true;
            }
            return false;
        }
        #endregion

        #region Light
        public int GetLightValue(int globalX, int y, int globalZ)
        {
            if (y >= 256 || y < 0)
            {
                return 15;
            } else
            {

                int chunkX = globalX >> 4;
                int chunkZ = globalZ >> 4;
                
                int relChunkX = chunkX - _chunkX;
                int relChunkZ = chunkZ - _chunkZ;
                
                int chunkposX = globalX - (chunkX * 16);
                int chunkposZ = globalZ - (chunkZ * 16);

                Chunk2 chunk;

                try
                {
                    chunk = GetChunk(relChunkX, relChunkZ);
                    if (chunk == null) 
                    {
                        return 15;
                    }
                    return (int)chunk.GetDaylightValue(chunkposX, y, chunkposZ);
                }
                catch
                {
                    //chunk = GetChunk(relX, relZ);
                    return 15;
                }

            }
        }
        
        public void SetLightValue(int globalX, int y, int globalZ, int level)
        {
            if (y >= 256 || y < 0)
            {
                return;
            } else
            {

                int chunkX = globalX >> 4;
                int chunkZ = globalZ >> 4;

                int relChunkX = chunkX - _chunkX;
                int relChunkZ = chunkZ - _chunkZ;
                
                int chunkposX = globalX - (chunkX * 16);
                int chunkposZ = globalZ - (chunkZ * 16);

                Chunk2 chunk;

                try
                {
                    chunk = GetChunk(relChunkX, relChunkZ);
                    if (chunk == null) 
                    {
                        return;
                    }
                    chunk.SetDaylightValue(chunkposX, y, chunkposZ, (byte)level);
                }
                catch
                {
                    return;
                }
            }
        }


        #endregion




    }
}

