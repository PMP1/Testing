//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;


namespace AssemblyCSharp
{
    public class ChunkRenderer
    {
        public GameObject sectionGo;
        private World world;
        private ChunkManager chunkManager;

        public List<Vector3> newVertices = new List<Vector3> ();
        public List<int> newTriangles = new List<int> ();
        public List<Vector2> newUV = new List<Vector2> ();
        public List<Vector3> newColliderVertices = new List<Vector3> ();
        public List<int> newColliderTriangles = new List<int> ();
        public List<Color> newColor = new List<Color> ();
        private float tUnit = 0.25f;

        public int faceCount = 0;

        private SectionColliderGenerator colliderGenerator;
        private bool smoothLighting = true;


        private Chunk2 chunk;
        private bool neighboursLoaded = false; 



        public ChunkRenderer(ChunkManager manager, World world)
        {
            this.chunkManager = manager;
            this.world = world;
            this.colliderGenerator = new SectionColliderGenerator(this);
        }
                
        public void RenderChunk(Chunk2 chunk) 
        {
            int firstSection = chunk.firstSection;
            byte daylightLevel = world.time.GetDaylightLevel();

            this.chunk = chunk;


            for (int secY = firstSection; secY >= 0; secY--) 
            {
                Section2 section = chunk.GetSection(secY);
                RenderSection(section, chunk, daylightLevel);
                section.RequiresGORedraw = true;
            }

            if (chunk.xPosition == 8 && chunk.zPosition == 10)
            {
                int ii = 0;
            }
            chunkManager.requiresGOgeneration.Enqueue(chunk);

            chunk.isSectionsRendered = true;
        }

        private void RenderSection(Section2 sec, Chunk2 chunk, byte daylight) 
        {
            System.DateTime startGenMesh = System.DateTime.Now;
            GenerateMesh(sec, chunk);
            StatsEngine.SectionMeshGen += (float)System.DateTime.Now.Subtract(startGenMesh).TotalSeconds;

            if (faceCount > 0)
            {
                System.DateTime startCreateCollider = System.DateTime.Now;
                colliderGenerator.GenerateCollisionMatrix(sec, ref newColliderTriangles, ref newColliderVertices);
                StatsEngine.SectionColliderGen += (float)System.DateTime.Now.Subtract(startCreateCollider).TotalSeconds;

                sec.SetMeshData(newVertices, newTriangles, newUV);
                sec.SetColorData(newColor);
                sec.SetColliderData(newColliderVertices, newColliderTriangles);
            }
            newUV.Clear();
            newVertices.Clear();
            newTriangles.Clear();
            newColor.Clear();
            faceCount = 0;

            newColliderTriangles.Clear();
            newColliderVertices.Clear();
        }

        private Block GetBlock(int x, int y, int z)
        {
            return BlockManager.GetBlock(GetBlockId(x, y, z));
        }

        //local values
        public byte GetBlockId(int x, int y, int z)
        {
            byte blockId = 3;
            
            if (y >= 256 || y < 0)
            {
                return (byte)0;
            } else
            {
                
                if (x < 0) 
                {
                    if (z < 0) 
                    {
                        blockId = chunk.ChunkSouthWest.GetBlockId(x + 16, y, z + 16);
                    } 
                    else if (z >= 16)
                    { 
                        blockId = chunk.ChunkNorthWest.GetBlockId(x + 16, y, z - 16);
                    }
                    else 
                    {
                        blockId = chunk.ChunkWest.GetBlockId(x + 16, y, z);
                    }
                } 
                else if (x >= 16)
                {
                    if (z < 0) 
                    {
                        blockId = chunk.ChunkSouthEast.GetBlockId(x - 16, y, z + 16);
                    } 
                    else if (z >= 16)
                    {
                        blockId = chunk.ChunkNorthEast.GetBlockId(x - 16, y, z - 16);
                    }
                    else 
                    {
                        blockId = chunk.ChunkEast.GetBlockId(x - 16, y, z);
                    }
                }
                else
                {
                    //center
                    if (z < 0) 
                    {
                        blockId = chunk.ChunkSouth.GetBlockId(x, y, z + 16);
                    } 
                    else if (z >= 16)
                    {
                        blockId = chunk.ChunkNorth.GetBlockId(x, y, z - 16);
                    }
                    else 
                    {
                        blockId = chunk.GetBlockId(x, y, z);
                    }
                }
                return blockId;
            }
        }

        //local values
        public byte GetDaylightValue(int x, int y, int z)
        {
            byte value = 15;
            
            if (y >= 256 || y < 0)
            {
                return (byte)15;
            } else
            {
                if (x < 0) 
                {
                    if (z < 0) 
                    {
                        value = chunk.ChunkSouthWest.GetDaylightValue(x + 16, y, z + 16);
                    } 
                    else if (z >= 16)
                    {
                        value = chunk.ChunkNorthWest.GetDaylightValue(x + 16, y, z - 16);
                    }
                    else 
                    {
                        value = chunk.ChunkWest.GetDaylightValue(x + 16, y, z);
                    }
                } 
                else if (x >= 16)
                {
                    if (z < 0) 
                    {
                        value = chunk.ChunkSouthEast.GetDaylightValue(x - 16, y, z + 16);
                    } 
                    else if (z >= 16)
                    {
                        value = chunk.ChunkNorthEast.GetDaylightValue(x - 16, y, z - 16);
                    }
                    else 
                    {
                        value = chunk.ChunkEast.GetDaylightValue(x - 16, y, z);
                    }
                }
                else
                {
                    //center
                    if (z < 0) 
                    {
                        value = chunk.ChunkSouth.GetDaylightValue(x, y, z + 16);
                    } 
                    else if (z >= 16)
                    {
                        value = chunk.ChunkNorth.GetDaylightValue(x, y, z - 16);
                    }
                    else 
                    {
                        value = chunk.GetDaylightValue(x, y, z);
                    }
                }
                
                
                return value;
            }
        }

        private void GenerateMesh(Section2 section, Chunk2 chunk) 
        {
            int posy;

            for (int x = 0; x < 16; x++)
            {
                for (int y = 0; y < 16; y++)
                {
                    for (int z = 0; z < 16; z++)
                    {
                        posy = y + (section.posY * 16);

                        byte id = section.GetBlockId(x, y, z);
                       



                        if (id != (byte)0)//|| block.LightOpacity < 16)
                        {
                            byte geo = section.GetGeoBlockId(x, y, z);


                            BlockGeo geoBlock = BlockGeoManager.geoList[geo];
                            Block block = BlockManager.GetBlock((byte)id);


                            System.DateTime startCreateSmoothLight;
                            double currentlighting = 0;

                            geoBlock.Render(block, this, x, y, posy, z);

                            StatsEngine.SectionSmoothLighting += (float)currentlighting;
                        }
                    }
                }
            }
        }


    }
}

