//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18063
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
namespace AssemblyCSharp
{
	public class PerlinNoise : INoise3D
	{
		private int[] noisePermutations;

		public PerlinNoise (int seed)
		{
			Random rand = new Random(seed);
			
			noisePermutations = new int[512];
			int[] noiseTable = new int[256];
			
			// Init. the noise table
			for (int i = 0; i < 256; i++) {
				noiseTable[i] = i;
			}
			
			// Shuffle the array
			for (int i = 0; i < 256; i++) {
				int j = rand.nextInt(256);
				
				int swap = noiseTable[i];
				noiseTable[i] = noiseTable[j];
				noiseTable[j] = swap;
			}
			
			// Finally replicate the noise permutations in the remaining 256 index positions
			for (int i = 0; i < 256; i++) {
				noisePermutations[i] = noiseTable[i];
				noisePermutations[i + 256] = noiseTable[i];
			}
		}

		public double Noise(double posX, double posY, double posZ) {
			int xInt = (int) PMath.FastFloor(posX) & 255;
			int yInt = (int) PMath.FastFloor(posY) & 255;
			int zInt = (int) PMath.FastFloor(posZ) & 255;
			
			double x = posX - PMath.FastFloor(posX);
			double y = posY - PMath.FastFloor(posY);
			double z = posZ - PMath.FastFloor(posZ);

			double u = Fade(x);
			double v = Fade(y);
			double w = Fade(z);
			int a = noisePermutations[xInt] + yInt;
			int aa = noisePermutations[a] + zInt;
			int ab = noisePermutations[(a + 1)] + zInt;
			int b = noisePermutations[(xInt + 1)] + yInt;
			int ba = noisePermutations[b] + zInt;
			int bb = noisePermutations[(b + 1)] + zInt;
			
			return Lerp(w, Lerp(v, Lerp(u, Grad(noisePermutations[aa], x, y, z),
			                            Grad(noisePermutations[ba], x - 1, y, z)),
			                    Lerp(u, Grad(noisePermutations[ab], x, y - 1, z),
			     Grad(noisePermutations[bb], x - 1, y - 1, z))),
			            Lerp(v, Lerp(u, Grad(noisePermutations[(aa + 1)], x, y, z - 1),
			             Grad(noisePermutations[(ba + 1)], x - 1, y, z - 1)),
			     Lerp(u, Grad(noisePermutations[(ab + 1)], x, y - 1, z - 1),
			     Grad(noisePermutations[(bb + 1)], x - 1, y - 1, z - 1))));
		}
		
		private static double Fade(double t) {
			return t * t * t * (t * (t * 6 - 15) + 10);
		}
		
		private static double Lerp(double t, double a, double b) {
			return a + t * (b - a);
		}
		
		private static double Grad(int hash, double x, double y, double z) {
			int h = hash & 15;
			double u = h < 8 ? x : y;
			double v = h < 4 ? y : h == 12 || h == 14 ? x : z;
			return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
		}

	}
}

