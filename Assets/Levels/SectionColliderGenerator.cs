//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
using AssemblyCSharp;

public class SectionColliderGenerator
{

	public int SectionSize { get; set; }
	public Section CurrentSection { get; set; }
	public Chunk CurrentChunk { get; set; }

    private Chunk2 currentChunk;
    private ChunkRenderer chunkRenderer;


	private List<Vector3> newColliderVertices = new List<Vector3> ();
	private List<int> newColliderTriangles = new List<int> ();
	private int colliderFaceCount = 0;


    public SectionColliderGenerator ()
    {
        
    }

    public SectionColliderGenerator(ChunkRenderer renderer)
    {
        chunkRenderer = renderer;
    }


	byte Block (int x, int y, int z)
	{
        return CurrentSection.Block(x, y, z);
	}

	/// <summary>
	/// Generates the collision mesh.
	/// </summary>
    public void GenerateCollisionMatrix (Section section)
    {
        /*SectionSize = section.sectionSize;
        
        bool [,] meshTop =      new bool[SectionSize,SectionSize];
        bool [,] meshBottom =   new bool[SectionSize,SectionSize];
        bool [,] meshEast =     new bool[SectionSize,SectionSize];
        bool [,] meshWest =     new bool[SectionSize,SectionSize];
        bool [,] meshNorth =    new bool[SectionSize,SectionSize];
        bool [,] meshSouth =    new bool[SectionSize,SectionSize];
        
        CurrentSection = section;
        CurrentChunk = section.chunk; 
        
        
        newColliderVertices = new List<Vector3> ();
        newColliderTriangles = new List<int> ();
        colliderFaceCount = 0;
        
        for (int y=0; y<SectionSize; y++) {
            for (int x=0; x<SectionSize; x++) {
                for (int z=0; z<SectionSize; z++) {
                    if (Block (x, y, z) != 0) {
                        if (Block (x, y + 1, z) <= 0) {
                            meshTop[x, z] = true;
                        }
                        if (Block (x, y - 1, z) <= 0) {
                            meshBottom[x, z] = true;
                        }
                    }
                }
            }
            CullCollisionMatrix(meshTop, y, 0);
            CullCollisionMatrix(meshBottom, y, 1);
        }
        
        for (int x=0; x < SectionSize; x++) {
            for (int y=0; y < SectionSize; y++) {
                for (int z=0; z < SectionSize; z++) {
                    if (Block (x, y, z) != 0) {
                        if (Block (x + 1, y, z) <= 0) {
                            meshEast[y, z] = true;
                        }
                        if (Block (x - 1, y, z) <= 0) {
                            meshBottom[y, z] = true;
                        }
                    }
                }
            }
            CullCollisionMatrix(meshEast, x, 3);
            CullCollisionMatrix(meshBottom, x, 5);
        }
        
        for (int z=0; z<SectionSize; z++) {
            for (int x=0; x<SectionSize; x++) {
                for (int y=0; y<SectionSize; y++) {
                    if (Block (x, y, z) != 0) {
                        if (Block (x, y, z + 1) <= 0) {
                            meshNorth[y, x] = true;
                        }
                        if (Block (x, y, z - 1) <= 0) {
                            meshSouth[y, x] = true;
                        }
                    }
                }
            }
            CullCollisionMatrix(meshNorth, z, 2);
            CullCollisionMatrix(meshSouth, z, 4);
        }
        section.hasCollisionMatrix = true;
        section.SetCollisionMesh (newColliderVertices, newColliderTriangles);
*/
    }

    public void GenerateCollisionMatrix(Chunk2 chunk)
    {

    }

    private byte GetBlockId(int x, int y, int z)
    {
        byte blockId = 3;
        
        if (y >= 256 || y < 0)
        {
            return (byte)0;
        }
        else
        {
            return currentChunk.GetBlockId(x, y, z);
        }


    }

    public void GenerateCollisionMatrix (Section2 section, ref List<int> tris, ref List<Vector3> verts)
    {
        bool [,] meshTop = new bool[16, 16];
        bool [,] meshBottom = new bool[16, 16];
        bool [,] meshEast = new bool[16, 16];
        bool [,] meshWest = new bool[16, 16];
        bool [,] meshNorth = new bool[16, 16];
        bool [,] meshSouth = new bool[16, 16];

        int posY = section.posY * 16;
        int posX = section.chunk.xPosition * 16;
        int posZ = section.chunk.zPosition * 16;

        newColliderVertices = new List<Vector3>();
        newColliderTriangles = new List<int>();
        colliderFaceCount = 0;

        currentChunk = section.chunk;
        
        for (int y = 0; y < 16; y++)
        {
            for (int x = 0; x < 16; x++)
            {
                for (int z = 0; z < 16; z++)
                {
                    if (section.GetBlockId(x, y, z) != (byte)0)
                    {
                        if (this.GetBlockId(x, y + posY + 1, z) <= (byte)0)
                        {
                            meshTop [x, z] = true;
                        }
                        if (this.GetBlockId(x, y + posY - 1, z) <= (byte)0)
                        {
                            meshBottom [x, z] = true;
                        }
                    }
                }
            }
            CullCollisionMatrix(meshTop, y, 0);
            CullCollisionMatrix(meshBottom, y, 1);
        }


        for (int x = 0; x < 16; x++)
        {
            for (int y = 0; y < 16; y++)
            {
                for (int z = 0; z < 16; z++)
                {
                    if (section.GetBlockId(x, y, z) != 0)
                    {
                        if (chunkRenderer.GetBlockId(x + 1, y + posY, z) <= 0)
                        {
                            meshEast [y, z] = true;
                        }
                        if (chunkRenderer.GetBlockId(x - 1, y + posY, z) <= 0)
                        {
                            meshBottom [y, z] = true;
                        }
                    }
                }
            }
            CullCollisionMatrix(meshEast, x, 3);
            CullCollisionMatrix(meshBottom, x, 5);
        }

        
        for (int z=0; z<16; z++)
        {
            for (int x=0; x<16; x++)
            {
                for (int y=0; y<16; y++)
                {
                    if (section.GetBlockId(x, y, z) != 0)
                    {
                        if (chunkRenderer.GetBlockId(x, y + posY, z + 1) <= 0)
                        {
                            meshNorth [y, x] = true;
                        }
                        if (chunkRenderer.GetBlockId(x, y + posY, z - 1) <= 0)
                        {
                            meshSouth [y, x] = true;
                        }
                    }
                }
            }
            CullCollisionMatrix(meshNorth, z, 2);
            CullCollisionMatrix(meshSouth, z, 4);
        }
        //section.hasCollisionMatrix = true;
        //section.SetCollisionMesh(newColliderVertices, newColliderTriangles);
        tris = newColliderTriangles;
        verts = newColliderVertices;
    }


	// top 0 bottom 1 N 2 E 3 S 4 W 5
	
	bool[,] CullCollisionMatrix(bool[,] mask, int dim, int type) {
		// this just sets up an example 2D plane for testing purposes
		int size = 16; // 7 x 7 plane 
		
		int i = 0; //start z
		int j = 0; //end z
		int h = 0;
		bool building;
		bool done = false;
		
		for (int x = 0; x < size; x ++) 
		{
			building = false;
			for (int z = 0; z < size; z ++) 
			{
				if (mask[x, z] == true && !building) // start recording a new rectangle
				{
					building = true;
					i = z; //start Z pos
				}
				// if you reach a block that needs no face, or you reach the end of the row, you're done
				if ((mask[x, z] == false && building) || (z == size-1 && building))
				{
					if (mask[x, z]==false && building) // -1 because you've already passed the last block
					{
						j = z - 1;
					}
					else
					{
						j = z;
					}
					building = false;
					done = false;
					h = 1; // height
					
					// look upwards to see if the row above this one needs faces in the exact same spots (width wise)
					// this loop is a little wonky but it works
					for (int x2 = x+1; x2 < size; x2 ++) 
					{
						for (int z2 = i; z2 <= j; z2 ++) 
						{
							if (mask[x2, z2] == false)
							{
								// cannot expand. get out of the loop.
								done = true;
								break;
							}
						}
						if (done)
							break;
						// we got to the end of the range so we're good! increase height and let's try the next row
						h += 1;
					}
					//# all done with this rectangle
					//# lower left coordinate of the RECTANGLE = x, i
					//# upper right coordinate of the RECTANGLE = x+h, j+1
					//print x, i, j, h	
					
					switch(type) {
						
					case 0://Top
						newColliderVertices.Add (new Vector3 (x, dim, j+1));
						newColliderVertices.Add (new Vector3 (x+h , dim, j+1));
						newColliderVertices.Add (new Vector3 (x+h, dim, i));
						newColliderVertices.Add (new Vector3 (x, dim, i));
						break;
					case 1://Bottom
						newColliderVertices.Add (new Vector3 (x, dim - 1, i));
						newColliderVertices.Add (new Vector3 (x+h , dim - 1, i));
						newColliderVertices.Add (new Vector3 (x+h, dim - 1, j+1));
						newColliderVertices.Add (new Vector3 (x, dim - 1, j+1));
						break;
					case 2://North
						newColliderVertices.Add (new Vector3 (j+1, x - 1,  dim + 1));
						newColliderVertices.Add (new Vector3 (j+1, x+h - 1, dim + 1));
						newColliderVertices.Add (new Vector3 (i,  x+h - 1, dim + 1));
						newColliderVertices.Add (new Vector3 (i, x - 1,  dim + 1));
						break;
					case 3: //East
						newColliderVertices.Add (new Vector3 (dim + 1, x - 1, i));
						newColliderVertices.Add (new Vector3 (dim + 1, x+h - 1, i));
						newColliderVertices.Add (new Vector3 (dim + 1, x+h - 1, j+1));
						newColliderVertices.Add (new Vector3 (dim + 1, x - 1, j+1));
						break;
					case 4: //South
						newColliderVertices.Add (new Vector3 (i, x - 1,  dim));
						newColliderVertices.Add (new Vector3 (i,  x+h - 1, dim));
						newColliderVertices.Add (new Vector3 (j+1, x+h - 1, dim));
						newColliderVertices.Add (new Vector3 (j+1, x - 1,  dim));
						break;
					case 5: //West
						newColliderVertices.Add (new Vector3 (dim, x - 1, j+1));
						newColliderVertices.Add (new Vector3 (dim, x+h - 1, j+1));
						newColliderVertices.Add (new Vector3 (dim, x+h - 1, i));
						newColliderVertices.Add (new Vector3 (dim, x - 1, i));
						
						break;
						
					}
					newColliderTriangles.Add (colliderFaceCount * 4); //1
					newColliderTriangles.Add (colliderFaceCount * 4 + 1); //2
					newColliderTriangles.Add (colliderFaceCount * 4 + 2); //3
					newColliderTriangles.Add (colliderFaceCount * 4); //1
					newColliderTriangles.Add (colliderFaceCount * 4 + 2); //3
					newColliderTriangles.Add (colliderFaceCount * 4 + 3); //4
					colliderFaceCount ++;				
					// update the mask to show that the spots covered by your rectangle no longer need faces
					for (int x3 = x; x3 < h+x; x3 ++) 
					{
						for (int z3 = i; z3 < j+1; z3 ++) 
						{
							mask[x3, z3] = false;
						}
					}
				}
			}
		}
		return mask;
	}
}


